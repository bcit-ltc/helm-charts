# SPDX-License-Identifier: MPL-2.0

# Global configuration settings
global:

  # -- Authoritative name
  name: "qcon-web"
  imagePullSecrets: []
  revisionHistoryLimit: 3
  progressDeadlineSeconds: 600

# -- Configuration for the service account
# @default -- `{}`
serviceAccount:

  # -- Enable or disable service account creation.
  create: true

  # -- Name of the service account to create. If empty uses global.name
  name: ""

  # Prior to v1.24.0, Kubernetes used to generate a secret for each service account by default.
  # Kubernetes now recommends using short-lived tokens from the TokenRequest API or projected volumes instead if possible.
  # For more details, see https://kubernetes.io/docs/concepts/configuration/secret/#service-account-token-secrets
  # -- Create a Secret API object to store a non-expiring token for the service account.
  createSecret: true

  # -- Extra labels to attach to the service account.
  #    Should be a YAML map of the labels to apply to the serviceAccount
  extraLabels: {}

  # Extra annotations to attach to the service account
  annotations: {}

# -- Enables a service for the app
# @default -- `{}`
service:

  # -- Enable or disable service components.
  enabled: true

  # -- Service type: by default, connect to the app using an internal cluster IP
  type: ClusterIP

  # -- Port on which the app is listening
  port: 8080

  # -- Target port to which the service should be mapped to
  targetPort: 8080

  # Extra annotations to attach to the service
  annotations: {}

# -- Configuration for the "frontend"
frontend:

  # -- Enable or disable frontend components.
  enabled: true

  # -- The name of the frontend container to create. If empty uses "frontend"
  name: nginx

  # -- Container image to use for the frontend
  image:

    # -- Frontend image pull policy
    pullPolicy: IfNotPresent

    # -- Image default registry
    registry: "docker.io"

    # -- Image default repository
    repository: "nginxinc/nginx-unprivileged"

    # -- Image default tag
    tag: "1.25-alpine"

  # Extra annotations to attach to the frontend
  annotations: {}

  # -- Add a checksum annotation to the server pods that is a hash
  #    of the configuration. Can be used to identify configuration changes.
  includeConfigAnnotation: false

  # -- Security context for the pod template and the app container<br>
  # @default -- 
  # Pod-level defaults:<br>
  #   &nbsp;&nbsp;runAsNonRoot: true<br>
  #   &nbsp;&nbsp;runAsGroup: 101<br>
  #   &nbsp;&nbsp;runAsUser: 101<br>
  #   &nbsp;&nbsp;fsGroup: 101<br>
  #   &nbsp;&nbsp;readOnlyRootFilesystem: true<br>
  #   &nbsp;&nbsp;allowPrivilegeEscalation: false<br>
  #
  # Container-level defaults:<br>
  # &nbsp;&nbsp;capabilities:<br>
  # &nbsp;&nbsp;&nbsp;&nbsp;drop:<br>
  # &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- ALL<br>
  securityContext:
    pod: {}
    container: {}

  resources:

    # -- Resource requests mapped directly to the value of
    #    the resources field for a PodSpec.
    requests:
      memory: 64Mi
      cpu: 100m

    # -- Resource limits mapped directly to the value of
    #    the resources field for a PodSpec.
    limits:
      memory: 256Mi
      cpu: 250m

  # -- Port on which the frontend is listening
  port: 8080

  # -- List of extra environment variables that are set literally.
  # @default -- `[]`
  extraEnvVars: []

  # -- configEnvs create ConfigMaps that are passed to containers using envFrom
  # @default -- `[]`
  configEnvs: []

  # -- Create `ConfigMap` resources that are projected through volumes. Must set matching configMounts.
  # @default -- `[]`
  configs:
    - name: nginx-config
      data:
        nginx.conf: |-
          upstream channels-backend {
              server 127.0.0.1:8000;
          }

          client_body_in_file_only clean;
          # client_body_temp_path /tmp 1 2;

          server {
              listen 8080 default_server;
              server_name _;

              client_max_body_size 20M;
              root /var/www/html;

              location / {
                  # checks for static file, if not found proxy to app
                  try_files $uri @proxy_to_app;
              }

              location /static/ {
                  autoindex on;
                  alias /var/www/html/static/;
              }

              location @proxy_to_app {
                  proxy_pass http://channels-backend;

                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";

                  proxy_redirect off;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Host $server_name;
              }

          }

  # -- volumeMounts for the frontend container that also create corresponding `emptyDir` volumes in the pod.
  # @default -- `[]`
  volumeMounts:
    - name: tmp
      mountPath: /tmp

  # -- volumeMounts to be added as configMaps. Requires matching configs.
  # @default -- `[]`
  configMounts:
    - name: nginx-config
      mountPath: /etc/nginx/conf.d

  # -- volumeMounts to be added as secrets
  # @default -- `[]`
  secretMounts: []

  # Defines custom livenessProbe settings
  livenessProbe:
    # -- Enables livenessProbe
    enabled: false
    # exec is preferred to httpGet (path) as the livenessProbe handler.
    execCommand: []
    # - /bin/sh
    # - -c
    # - <command>
    # Path for the httpGet handler
    path: "/"
    # Port number on which livenessProbe will be checked if httpGet is used as the livenessProbe handler
    port: 8080
    # When a probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 2
    # Number of seconds after the container has started before probe initiates
    initialDelaySeconds: 10
    # How often (in seconds) to perform the probe
    periodSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # Number of seconds after which the probe times out.
    timeoutSeconds: 5

  # Defines custom readinessProbe settings
  readinessProbe:
    # -- Enables readinessProbe
    enabled: false
    # If you need to use a http path instead of the default exec
    # path: /health?standbyok=true
    # Port number on which readinessProbe will be checked.
    port: 8080
    # When a probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 2
    # Number of seconds after the container has started before probe initiates
    initialDelaySeconds: 5
    # How often (in seconds) to perform the probe
    periodSeconds: 10
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # Number of seconds after which the probe times out.
    timeoutSeconds: 5

  # Defines custom startupProbe settings
  startupProbe:
    # -- Enables startupProbe
    enabled: false
    # When a probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 12
    # Number of seconds after the container has started before probe initiates
    initialDelaySeconds: 5
    # How often (in seconds) to perform the probe
    periodSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # Number of seconds after which the probe times out.
    timeoutSeconds: 5


# -- Main "backend" configuration
# @default -- `{}`
processor:

  # -- Enable or disable processor components.
  enabled: true
  image:

    # -- Image default pull policy
    pullPolicy: IfNotPresent

    # -- Image default registry
    registry: "ghcr.io"

    # -- Image default repository
    repository: "bcit-ltc/qcon-api"

    # -- Image default tag
    tag: "1.1.0"

  # -- Number of replicas for the processor
  replicas: 1

  # -- Extra labels to attach to the processor pods
  #    Should be a YAML map of the labels to apply to the deployment template
  extraLabels: {}

  # Extra annotations to attach to the processor deployment
  annotations: {}

  # -- Port on which processor is listening
  port: 8000

  # -- List of extra environment variables that are set literally.
  # @default -- `[]`
  extraEnvVars: []
  # - API_URL: "https://app.ltc.bcit.ca/api"

  # extraEnvVars:
  #   - GIT_TAG: "v1.0.2" # should match processor.image.tag

  # -- Create `ConfigMap` resources that are passed to containers using envFrom
  # @default -- `[]`
  configEnvs: []

  # -- Create `ConfigMap` resources that are projected through volumes. Must set matching configMounts.
  # @default -- `[]`
  configs: []

  # -- volumeMounts for the processor container that also create corresponding emptyDir volumes in the pod.
  # @default -- `[]`
  volumeMounts: []
    # - name: shared-data
    #   mountPath: /var/www/html

  # -- volumeMounts to be added as configMaps. Requires matching configs.
  # @default -- `[]`
  configMounts: []

  # -- volumeMounts to be added as secrets
  # @default -- `[]`
  secretMounts:

    # Credentials to access the app internal management portal (local account)
    - name: app-internal-credentials
      secretName: app-internal-credentials
      mountPath: /etc/secrets/app-internal-credentials
      items: # optional: map specific keys to paths (and per-file mode)
        - key: ADMIN_USERNAME
          path: ADMIN_USERNAME
        - key: ADMIN_PASSWORD
          path: ADMIN_PASSWORD
        - key: DJANGO_SECRET_KEY
          path: DJANGO_SECRET_KEY

    - name: db-credentials # volume name (must be DNS-1123 compliant)
      secretName: db-credentials # existing Secret in the same namespace
      mountPath: /etc/secrets/db-credentials
      readOnly: true # defaults to true if omitted
      optional: false # allow pod to start if Secret missing? (default false)
      items: # optional: map specific keys to paths (and per-file mode)
        - key: POSTGRES_DB
          path: POSTGRES_DB
        - key: POSTGRES_USER
          path: POSTGRES_USER
        - key: POSTGRES_PASSWORD
          path: POSTGRES_PASSWORD
        - key: POSTGRES_HOST
          path: POSTGRES_HOST

    - name: api-key
      secretName: api-key
      mountPath: /etc/secrets/api-key
      readOnly: true
      items: # optional: map specific keys to paths (and per-file mode)
        - key: API_KEY
          path: API_KEY

# -- Creates an ingress for external access
# @default -- `{}`
ingress:

  # -- Enable or disable ingress components.
  enabled: true

  # -- Extra labels to attach to the processor pods
  #    Should be a YAML map of the labels to apply to the deployment template
  extraLabels: {}

  # -- Extra annotations to attach to the ingress resource
  annotations: {}

  # -- Default IngressClass to use. If empty, use the cluster's default
  ingressClassName: ""

  # As of Kubernetes 1.19, all Ingress Paths must have a pathType configured. The default value below should be sufficient in most cases.
  # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types for other possible values.
  # -- Ingress pathType
  pathType: Prefix

  # -- Ingress host definitions
  # @default -- `[]`
  hosts:
    - host: "ltc.bcit.ca"
      paths: []

  # -- Extra paths to include in the ingress
  extraPaths: []
  #   - path: /api
  #     backend:
  #       service:
  #         name: api-service
  #         port:
  #           number: 3000

  # -- TLS configuration for the ingress
  # @default -- `[]`
  tls:
    - secretName: "star-ltc-bcit-ca"
      hosts:
        - "ltc.bcit.ca"


# Configuration for persistent volume claims
dataStorage:
  # -- Enable or disable data storage components.
  enabled: false
  # -- Size of the PVC created
  size: 10Gi
  # -- Location where the PVC will be mounted.
  mountPath: "/app/data"
  # -- Name of the storage class to use. If null it will use the
  # configured default Storage Class.
  storageClass: null
  # -- Access Mode of the storage device being used for the PVC
  accessMode: ReadWriteOnce
  # -- Annotations to apply to the PVC
  annotations: {}
  # -- Labels to apply to the PVC
  labels: {}

# Unconfigured options
#
# autoscaling:
#   enabled: false
#   minReplicas: 2
#   maxReplicas: 5
#   targetCPUUtilizationPercentage: 80
# pdb:
#   enabled: false
#   minAvailable: 1
# networkPolicy:
#   enabled: false
