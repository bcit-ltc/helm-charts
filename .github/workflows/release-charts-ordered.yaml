name: Release charts (library first, then apps)

on:
  push:
    branches: [ main ]
  workflow_run:
    workflows: [ "Remotely-triggered chart bump & commit" ]
    branches:   [ main ]
    types: [ completed ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  GH_PAGES_URL: https://bcit-ltc.github.io/helm-charts
  LIB_NAME: apps-common
  CHARTS_DIR: charts

jobs:
  # 1) Package and release ONLY the library chart to gh-pages first
  release-lib:
    name: Release library chart
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure Git identity
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run chart-releaser for library
        uses: helm/chart-releaser-action@v1.6.0
        with:
          charts_dir: charts/apps-common   # only the library folder
          skip_existing: true              # do not fail if the release tag already exists
        env:
          CR_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # 2) Package and release ALL charts (apps) — now that the lib is indexed
  release-apps:
    name: Release app charts
    needs: release-lib
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure Git identity
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # Helm needed for dep build and packaging
      - uses: azure/setup-helm@v4
        with: { version: v3.14.4 }

      # Add gh-pages repo so deps resolve
      - name: Add chart repos for dependencies
        run: |
          set -euo pipefail
          helm repo add bcit-ltc https://bcit-ltc.github.io/helm-charts || true
          helm repo update

      # Install yq for parsing Chart.yaml
      - uses: mikefarah/yq@v4.44.3

      # Pre-vendor library deps (apps-common) into each app's charts/ dir
      - name: Pre-vendor library dependencies (apps-common)
        run: |
          set -euo pipefail
          for d in charts/*; do
            [[ -f "$d/Chart.yaml" ]] || continue
            [[ "$(basename "$d")" == "apps-common" ]] && continue
            if yq -e '.dependencies[] | select(.name=="apps-common")' "$d/Chart.yaml" > /dev/null 2>&1; then
              ver="$(yq -r '.dependencies[] | select(.name=="apps-common") | .version' "$d/Chart.yaml")"
              echo "==> Vendoring apps-common@$ver into $d/charts/"
              mkdir -p "$d/charts"
              helm pull bcit-ltc/apps-common --version "$ver" --untar --untardir "$d/charts"
              ls -la "$d/charts" || true
            fi
          done

      # (Optional) Build deps for any other repos you might depend on
      - name: Build chart dependencies (apps)
        run: |
          set -euo pipefail
          for d in charts/*; do
            [[ -f "$d/Chart.yaml" ]] || continue
            [[ "$(basename "$d")" == "apps-common" ]] && continue
            echo "==> helm dependency build $d"
            helm dependency build "$d"
          done

      # Package app charts ourselves (pre-package)
      - name: Package app charts (pre-package)
        run: |
          set -euo pipefail
          mkdir -p .cr-release-packages
          for d in charts/*; do
            [[ -f "$d/Chart.yaml" ]] || continue
            [[ "$(basename "$d")" == "apps-common" ]] && continue
            echo "==> helm package $d -d .cr-release-packages"
            helm package "$d" -d .cr-release-packages
          done
          ls -la .cr-release-packages

      # Install the chart-releaser CLI only (we'll run cr ourselves)
      - name: Install chart-releaser CLI
        uses: helm/chart-releaser-action@v1.6.0
        with:
          install_only: true
        env:
          CR_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Upload prebuilt packages to Releases (idempotent)
      - name: Upload packages to Releases (cr upload)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cr upload \
            --owner "${GITHUB_REPOSITORY_OWNER}" \
            --git-repo "${GITHUB_REPOSITORY#*/}" \
            --skip-existing \
            --token "${GH_TOKEN}"

      # Rebuild gh-pages index using helm repo index (avoids cr index bug)
      - name: Rebuild gh-pages index (helm repo index)
        env:
          REPO_URL: https://bcit-ltc.github.io/helm-charts
        run: |
          set -euo pipefail

          # Prepare a clean gh-pages worktree
          git fetch origin gh-pages:gh-pages || true
          rm -rf .gh-pages
          if git show-ref --verify --quiet refs/heads/gh-pages; then
            git worktree add .gh-pages gh-pages
          else
            # Create orphan gh-pages if it doesn't exist
            git worktree add .gh-pages -b gh-pages
            (cd .gh-pages && git commit --allow-empty -m "init gh-pages")
          fi

          # Copy newly built packages into the pages dir
          mkdir -p .gh-pages
          cp -f .cr-release-packages/*.tgz .gh-pages/ || true

          # Merge/update index.yaml
          if [[ -f .gh-pages/index.yaml ]]; then
            echo "Merging into existing index.yaml"
            helm repo index .gh-pages --url "${REPO_URL}" --merge .gh-pages/index.yaml
          else
            echo "Creating new index.yaml"
            helm repo index .gh-pages --url "${REPO_URL}"
          fi

          # Commit and push the updated index and packages
          git -C .gh-pages add -A
          if ! git -C .gh-pages diff --cached --quiet; then
            git -C .gh-pages commit -m "index: update Helm chart repo"
            git -C .gh-pages push origin gh-pages
          else
            echo "No changes to gh-pages."
          fi

  # 3) Publish packaged charts to GHCR
  publish-oci:
    name: Publish OCI charts to GHCR
    needs: release-apps
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - uses: azure/setup-helm@v4
        with: { version: v3.14.4 }

      - name: Login to GHCR (Helm)
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io \
            -u "${{ github.actor }}" --password-stdin

      - name: Login to GHCR (Cosign)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Gather latest packaged chart assets (one release per chart)
        id: tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p dist

          # Fetch up to 100 recent releases, drop drafts, and select only names that look like <chart>-<version>.
          # Derive the chart name by stripping the trailing "-<version>" segment, then group by chart
          # and pick the most recently published release for each chart.
          mapfile -t LATEST_PER_CHART < <(
            gh release list --limit 100 --json name,publishedAt,isDraft |
            jq -r '
              map(select(.isDraft == false))                                       # ignore drafts
              | map(select(.name | test(".+-[0-9]")))                              # must look like "<chart>-<version>"
              | map(.chart = (.name | sub("-[0-9].*$"; "")))                       # derive chart name
              | group_by(.chart)                                                   # group releases per chart
              | map(max_by(.publishedAt))                                          # pick most recent per chart
              | .[].name
            '
          )

          if (( ${#LATEST_PER_CHART[@]} == 0 )); then
            echo "No matching releases found."
          else
            printf 'Latest releases per chart:\n%s\n' "$(printf '%s\n' "${LATEST_PER_CHART[@]}")"
          fi

          # Download only the selected releases' chart packages (*.tgz)
          for rel in "${LATEST_PER_CHART[@]}"; do
            echo "==> Downloading assets for release: $rel"
            gh release download "$rel" --pattern '*.tgz' --dir dist || true
          done

          shopt -s nullglob
          files=(dist/*.tgz)
          if (( ${#files[@]} )); then
            tags=$(printf '%s\n' "${files[@]}" | sed -E 's,.*/(.*)\.tgz$,\1,' | jq -R . | jq -sc .)
          else
            tags="[]"
          fi
          echo "list=$tags" >> "$GITHUB_OUTPUT"
          echo "Packaged tags: $tags"

      - uses: sigstore/cosign-installer@v3

      - uses: imjasonh/setup-crane@v0.4
        with: { version: v0.20.1 }

      - name: Push & sign charts to GHCR by digest
        if: ${{ steps.tags.outputs.list != '' && steps.tags.outputs.list != '[]' }}
        env:
          OWNER: ${{ github.repository_owner }}
          LIB_NAME: ${{ env.LIB_NAME }}
        run: |
          set -euo pipefail
          repo="oci://ghcr.io/${OWNER}/oci"

          # Sanitize workflow name for Cosign annotation (alnum + . _ - only)
          WORKFLOW_SAFE="$(printf '%s' "${GITHUB_WORKFLOW:-}" | tr -c '[:alnum:]._-' '_')"

          for pkg in dist/*.tgz; do
            name="$(helm show chart "$pkg" | awk -F': ' '/^name:/{print $2; exit}')"
            version="$(helm show chart "$pkg" | awk -F': ' '/^version:/{print $2; exit}')"

            # Skip pushing the library chart to OCI (optional)
            if [[ "$name" == "${LIB_NAME}" ]]; then
              echo "Skipping OCI publish for library chart: $name"
              continue
            fi

            PUSH_OUT="$(helm push "$pkg" "${repo}" 2>&1 | tee /dev/stderr)"
            DGST="$(printf '%s\n' "$PUSH_OUT" | tr -d '\r' | awk 'tolower($1)=="digest:" {print $2; exit}')"
            [[ -n "$DGST" && "$DGST" =~ ^sha256:[0-9A-Fa-f]{64}$ ]] || { echo "Failed to parse digest"; exit 1; }

            REF="ghcr.io/${OWNER}/oci/${name}"
            echo "Signing ${REF}@${DGST} with Cosign (keyless)…"
            cosign sign --yes \
              -a "chart.name=${name}" \
              -a "chart.version=${version}" \
              -a "repo=${GITHUB_REPOSITORY}" \
              -a "workflow=${WORKFLOW_SAFE}" \
              -a "sha=${GITHUB_SHA}" \
              "${REF}@${DGST}"

            # Add 'latest' tag
            crane tag "${REF}@${DGST}" latest
          done
